# 5.3 Review RAG Implementation

1. Implement RAG (Function calling review)
   1. Show how to use LangChain's `StructuredTool` (or whatever it is) to call existing functions to get info from the database for RAG
   2. Embed incoming user messages for similarity search and semantic ranker capablities

## 3.7. Let's Connect The Dots ðŸ’¡

!!! info "Recall that the [Retrieval Augmented Generation](https://learn.microsoft.com/en-us/azure/ai-studio/concepts/retrieval-augmented-generation#how-does-rag-work) works by *retrieving* relevant knowledge from your data stores, and _augmenting_ the user query with it to create an enhanced prompt - which _generates_ the final response."

To implement this RAG pattern, we need to execute three steps:

1. **Setup data sources** and populate them with our data (product catalog, customer orders)
1. **Create [indexes](https://learn.microsoft.com/azure/ai-studio/concepts/retrieval-augmented-generation#how-does-rag-work)** for efficient information retrieval by LLMs (e.g., find matching products)
1. **Connect our Azure AI project** to access data/indexes code-first, for use in processing steps.

In the previous section we setup the data sources (provisioning infra) and populated them with data (post-provisioning scripts) as follows:

1. **Azure CosmosDB** - loaded **12 records** from `data/customer_info`, got _customers_ database.
1. **Azure AI Search** - loaded **20 records** from `data/product_info`, got _contoso-products_ index.

This checks off the first two idents from our RAG checklist above. Now, let's see how we can achieve the thirst ep with a code-first approach that makes use of the Azure AI Search, Azure CosmosDB and Azure OpenAI services through their Azure SDKs.

## Hybrid Search

Hybrid search in Azure Database for PostgreSQL combines traditional full-text search functionality with the vector similarity search capabilites enabled by the `azure_ai` and `vector` extensions to deliver highly relevant results. This dual approach leverages the precision of keyword matching with full-text search and the contextual understanding of vector search, ensuring that users obtain both exact matches and semantically related content. This synergy enhances search efficiency, provides a richer user experience, and supports diverse use casesâ€”from technical document retrieval to broad content discoveryâ€”making it an invaluable tool for modern copilots.

### Why It's Better

By integrating full-text search and vector similarity search, hybrid search maximizes the relevance and comprehensiveness of search results, providing users with more accurate and meaningful information.

1. **Comprehensive Results**
    - **Full-Text Search**: Uses keyword matching for precise term searches.
    - **Vector Search**: Uses vector similarity to find contextually relevant results.
    - **Hybrid**: Combines both to ensure exact and semantically similar results.

2. **Enhanced Relevance**
    - Prioritizes exact matches from full-text search while including contextually significant results from vector search.

3. **Improved User Experience**
    - Balances precision (full-text) and relevance (vector) for satisfying search outcomes.

4. **Versatility**
    - Supports varied use cases from technical documents to content discovery by integrating both search techniques.

5. **Efficient Resource Use**
    - Optimizes search efficiency by leveraging both full-text and vector search.

## Enable Hybrid Search in PostgreSQL

To allow search results against the database to use traditional full-text search combined with vector similarity seearch, you can combine both approaches in a single query to leverage the strengths of traditional keyword search and vector similarity search.

1. In pgAdmin, open a new query tool window for your database.

2. In the new query window, paste the following SQL statement to create a function for performing a hybrid search against the `invoice_validation_results` table...

    TODO: Need to have them review the below function first, then copy it into a pgAdmin query window and run it...

    !!! info "PostgreSQL Hybrid Search Function"

        ```sql linenums="1" title="get_similar_invoices"
        CREATE OR REPLACE FUNCTION get_similar_invoices(query_text TEXT, max_results INT DEFAULT 5, vendor INT DEFAULT NULL)
        RETURNS TABLE(
            id BIGINT,
            number TEXT,
            vendor_id BIGINT,
            sow_id BIGINT,
            amount NUMERIC,
            invoice_date DATE,
            payment_status VARCHAR(50),
            datestamp TIMESTAMP,
            result TEXT,
            validation_passed BOOLEAN,
            rank REAL
        ) AS $$
        DECLARE 
            query_embedding vector(3072);
        BEGIN
            query_embedding := (
                azure_openai.create_embeddings('embeddings', query_text, max_attempts => 5, retry_delay_ms => 500)::vector
            );
        
            RETURN QUERY
            SELECT i.id, i.number, i.vendor_id, i.sow_id, i.amount, i.invoice_date, i.payment_status, r.datestamp, r.result, r.validation_passed,
                CASE
                    WHEN r.result ILIKE '%' || query_text || '%' THEN 0 -- Exact match ranks highest
                    ELSE (r.embedding <=> query_embedding)::real
                END AS rank
            FROM invoices AS i
            INNER JOIN invoice_validation_results as r ON i.id = r.invoice_id -- Only get invoices that have validation results
            WHERE (i.vendor_id = vendor OR vendor IS NULL)
            ORDER BY rank ASC
            LIMIT max_results;
        END $$ LANGUAGE plpgsql
        ```
        
        In this function:
        
        - The CASE statement assigns a rank of 0 to rows where text_field contains the exact search term (ILIKE '%search_term%').
        
        - For all other rows, the rank is based on the vector distance, which ensures that semantically similar results are included.
        
        - The results are then ordered by the rank, with exact matches ranking highest, followed by the most semantically similar results.
        
        - Finally, we limit the results to the top 100.
        
        This approach allows you to prioritize exact keyword matches while still incorporating the benefits of vector similarity search.
        
        TODO: Test the above, and implement something like also restricting to a particular vendor?
        

    TODO: Provide details and review the various lines/parts of the above function

3. Run the query using the **Execute script** button on the pgAdmin toolbar.

4. Test out the function by running the following query:

    ```sql
    SELECT * FROM get_ranked_invoices('amount was wrong', 1);
    ```

## Allow Hybrid Search From Chat Endpoint

TODO: Review existing code in the `get_similar_invoice_validation_results` function...

!!! info "Hybrid Search Implementation"

    ```python linenums="1" title="src/api/app/routers/completions.py"
    async def get_similar_invoice_validation_results(user_query: str, vendor_id: int = None):
        """
        Retrieves a list of invoice validation results similar to the user query for the specified vendor.
        If no vendor_id is provided, invoice validation results for all vendors are returned.
        """
        pool = await get_db_connection_pool()
        async with pool.acquire() as conn:
            if vendor_id is not None:
                query = f"SELECT * FROM get_ranked_sows('{user_query}', {vendor_id});"
            else:
                query = f"SELECT * FROM get_ranked_sows('{user_query}');"
            
            rows = await conn.fetch(query)
            invoices = [dict(row) for row in rows]
        return invoices
    ```
