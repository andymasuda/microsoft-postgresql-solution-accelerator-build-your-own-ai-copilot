# 3.4 Optimize vector performance with DiskANN

TODO: Rewrite all of this, as it is simply a copy of the docs at <https://learn.microsoft.com/en-us/azure/postgresql/flexible-server/how-to-optimize-performance-pgvector#disk-approximate-nearest-neighbor-diskann>

TODO: Keep the above link and point to it somewhere in this doc as a reference...

DiskANN is a scalable approximate nearest neighbor search algorithm for efficient vector search at any scale. It offers high recall, high queries per second (QPS), and low query latency, even for billion-point datasets. This makes it a powerful tool for handling large volumes of data. [Learn more about DiskANN from Microsoft](https://aka.ms/pg-diskann-docs).

## Index options

When creating an index with diskann, you can specify various parameters to control its behavior. Here are the options that we currently have:

1. `max_neighbors`: Maximum number of edges per node in the graph. (Defaults to 32)
2. `l_value_ib`: The size of the search list during index build (Defaults to 50)

```sql
CREATE INDEX my_table_embedding_diskann_custom_idx ON my_table USING diskann (embedding vector_cosine_ops)
WITH (
 max_neighbors = 48,
 l_value_ib = 100
 );
```

The L value for index scanning (`l_value_is`) can be set for the whole connection or per transaction (using `SET LOCAL` within a transaction block):

```sql
SET diskann.l_value_is = 100;
SELECT * FROM my_table ORDER BY embedding <=> '[1,2,3]' LIMIT 5; -- uses 100 candidates
```

Postgres will automatically decide when to use the DiskANN index. If there are scenarios you always want to use the index, use the following command:

```sql
SET LOCAL enable_seqscan TO OFF;
SELECT * FROM my_table ORDER BY embedding <=> '[1,2,3]' LIMIT 5; -- forces the use of index
```

## Selecting the index access function

TODO: Rework the below so we only worry about `diskann` and the `vector_cosine_ops` access function.

The `vector` type allows you to perform three types of searches on the stored vectors. You need to select the correct access function for your index in order to have the database consider your index when executing your queries. The examples demonstrate on `ivfflat` index types, however the same can be done for `hnsw` and `diskann` indexes. The `lists` option only applies to `ivfflat` indexes.

For cosine similarity search, use the `vector_cosine_ops` access method.

```sql
CREATE INDEX t_test_embedding_cosine_idx ON t_test USING ivfflat (embedding vector_cosine_ops) WITH (lists = 100);
```

To use the above index, the query needs to perform a cosine similarity search, which is done with the `<=>` operator.

```sql
EXPLAIN SELECT * FROM t_test ORDER BY embedding <=> '[1,2,3]' LIMIT 5;
```

