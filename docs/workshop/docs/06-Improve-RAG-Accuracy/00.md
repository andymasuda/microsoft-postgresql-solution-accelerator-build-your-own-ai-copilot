# 5.6 Use Semantic Ranking

- TODO
  - Review ranking model deployed in Azure Machine Learning Studio
  - Implement ranker in query/endpoint
  - Figure out what else should be done here

Use this blob post as a guide for this content: https://techcommunity.microsoft.com/blog/adforpostgresql/introducing-the-semantic-ranking-solution-for-azure-database-for-postgresql/4298781

This solution accelerator is designed to extend your PostgreSQL instance on Azure with the ability to perform semantic ranking directly in the SQL query language. The solution accelerator provides two components:

1. Automated Deployment Script: This script provisions the Semantic Ranker model as an Azure Machine Learning (AML) inference endpoint in your subscription.
2. SQL Integration: A SQL User Defined Function (UDF) integrates the Semantic Ranker model directly into SQL queries. The function makes use of the azure_ai extension to make remote calls to the AML inference endpoint.

The architecture of the Solution Accelerator is shown below:

![](../img/semantic-ranking-solution-architecture.png)

!!! success "CONGRATULATIONS. You just learned how to leverage the semantic ranking capabilities in Azure Database for PostgreSQL!"


Semantic Ranking model:

https://huggingface.co/BAAI/bge-reranker-v2-m3


```sql
CREATE OR REPLACE FUNCTION semantic_reranking(query TEXT, vector_search_results TEXT[])
RETURNS TABLE (article TEXT, relevance jsonb) AS $$
BEGIN
    RETURN QUERY
        WITH
        json_pairs AS(
        SELECT jsonb_build_object(
                    'pairs', 
                    jsonb_agg(
                        jsonb_build_array(query, article_)
                    )
                ) AS json_pairs_data
                FROM (
                    SELECT a.article as article_
                    FROM unnest(vector_search_results) as a(article)
                )
        ), 
        relevance_scores AS(
            SELECT jsonb_array_elements(invoke.invoke) as relevance_results
            FROM azure_ml.invoke(
                        (SELECT json_pairs_data FROM json_pairs),
                        deployment_name=>'bgev2m3-v1', timeout_ms => 120000)
        ),
        relevance_scores_rn AS (
            SELECT *, ROW_NUMBER() OVER () AS idx
            FROM relevance_scores
        )
        SELECT a.article,
               r.relevance_results
            FROM
                unnest(vector_search_results) WITH ORDINALITY AS a(article, idx2)
            JOIN
                relevance_scores_rn AS r(relevance_results, idx)
            ON
                a.idx2 = r.idx;

END $$ LANGUAGE plpgsql;
```
